	->>>  NUMPY LIBRARY  <<<-

import numpy as np

Operators
	Basic
		-> Check Python universal functions
		arr1 + arr2: sums one by one the elements of each arrays
		arr1 * arr2: multiplies one by one the elements of each arrays
		arr + k: sums k to each element of array
		arr * k: multiplies k to each element of array
		arr ** k: elevates to the power of k each element of the array
		np.sqrt(arr): returns the sqared root of each element
		np.sin(arr)/cos(arr)log(arr)/exp(arr): returns the function elementwise
		np.sum(arr) OR arr.sum(): sums all elements of the array
		np.std(arr) OR arr.std(): gives standard deviation of array
		sum(arr): sums all rows of the array
		sum(axis=i): i=0 sums all rows, i=1, sums all columns
		len(array): returns the length of the array
	Create Arrays
		np.array(list): converts a list (vect or mat)into an array
		np.arange(s,e+1,stp): Creates an evenly spaced vector with a step stp 
							  starting at s and ending at e (does not include
							  e+1)
		np.linspace(s,e,n): Creates an evenly spaced vector of n elemets 
							starting at s and ending at e
		np.zeros((r,c)): creates a matrix ofzeros of r rows and c columns
						 (Note that input should be a tuple)
						 -If input is a scalar, it will create a vector
		np.ones((r,c)): creates mateix of ones
		np.eye(r): creates an identity matrix of r rows
		np.random.rand((r,c)): creates matrix of r rows and c columns of random
							   numbers b/w 0 and 1 following an uniform distr
							   (can use a lot of other distr)
		np.random.randn(r,c): random numbers following normal distr with mu=0
								 and sigma = 1 (do not use a tuple in this one)
		np.random.randint(s,e,(r,c)): creates a matrix of random values between 
									s and e
	Reshape/copy
		arr.reshape(r,c): reshapes array of values (vector or whatever) into a new
						  matrix of r rows and c columns (len(array) needs to = r*c)
		arr.copy(): creates a copy of the array arr
	Indexing (in python indexes start at 0)
		-Note on indexing: if we use indexing to create a smaller vector from a 
		 bigger one, if we change the value of the small, the big will also be
		 affected (we can solve this problem by creating a copy of the vector)
		1D (Vectors)
			arr[n]: gives nth number of the array (can be used to set)
			arr[s,e]: gives sth to eth (not included) element of the array
			arr[s:]: gives sth element of the array until the end
			arr[:e+1]: gives start until eth (not included)element of the array
		2D (Matrices)
			arr[r,c] (OR arr[r][c]) : will give the element of the row r and column c
									  can use 's:e' notation to grab parts
					note: to select full columns (and avoid numpy selecting them as
						  row), we will need to indicate arr(:,c:(c+1)), where c is the
						  column we want.
			arr[-r,-c]: gives numbers of rows and cols starting from the end (count
						starts at 1)
			arr[r]: will give all the r row of the matrix
	Boolean Operators
		arr > k: will give a boolean array bool_arr that verifyes the condition,
				 in this case, digits that are > k (can use >,<,==,!=...)
		arr[bool_arr]: returns the indexes of arr that are True in bool_arr
					   (note that dim(arr) should = dim(bool_arr))
		arr[arr > k]: directly gives the sub-set of arr that verifyes the boolean 
					  condition in the brackets
	Matrix rand
		np.matmul(A,B): multiplies matrices A & B
		np.transpose(A): transposes matrix A
		np.random.randn(rows,cols)
			-> creates a matrix of the dimensions specified with random numbers
			   of a normal distribution of mean 0 and std 1
Functions
		arr.max(): gives max value of an array arr
		arr.argmax(): gives in which argumment of the array arr the max value is
					  located
		arr.min(): gives min value of an array arr
		arr.argmin(): gives in which argumment of the array arr the min value is
					  located
		arr.shape: gives the tuple with the number of rows and cols (r,c)
		np.mean(list): returns the mean of all values in the list
PCA
		np.cov(dataset)
			-> computes the covariance matrix of the dataset (data must be stored
			   by rows)
		eigVal, eigVec = np.linalg.eig(cov_matrix)
			-> computes the eigenvalues (1D vector) and eigenvectors (matrix, vectors
			   by columns)
		